// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: setting.sql

package db

import (
	"context"
	"time"
)

const createSetting = `-- name: CreateSetting :exec
insert into setting (account_id, relation_id, nick_name, is_leader, is_self)
values ($1, $2, '', $3, $4)
`

type CreateSettingParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
	IsLeader   bool  `json:"is_leader"`
	IsSelf     bool  `json:"is_self"`
}

func (q *Queries) CreateSetting(ctx context.Context, arg *CreateSettingParams) error {
	_, err := q.db.Exec(ctx, createSetting,
		arg.AccountID,
		arg.RelationID,
		arg.IsLeader,
		arg.IsSelf,
	)
	return err
}

const deleteSetting = `-- name: DeleteSetting :exec
delete
from setting
where account_id = $1
  and relation_id = $2
`

type DeleteSettingParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
}

func (q *Queries) DeleteSetting(ctx context.Context, arg *DeleteSettingParams) error {
	_, err := q.db.Exec(ctx, deleteSetting, arg.AccountID, arg.RelationID)
	return err
}

const existsFriendSetting = `-- name: ExistsFriendSetting :one
select exists(
               select 1
               from setting s,
                    relation r
               where r.relation_type = 'friend'
                 and ((r.friend_type).account1_id = $1::bigint and
                      (r.friend_type).account2_id = $2::bigint)
                 and s.account_id = $1
           )
`

type ExistsFriendSettingParams struct {
	Account1ID int64 `json:"account1_id"`
	Account2ID int64 `json:"account2_id"`
}

func (q *Queries) ExistsFriendSetting(ctx context.Context, arg *ExistsFriendSettingParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsFriendSetting, arg.Account1ID, arg.Account2ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsSetting = `-- name: ExistsSetting :one
select exists(
               select 1
               from setting
               where account_id = $1
                 and relation_id = $2
           )
`

type ExistsSettingParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
}

func (q *Queries) ExistsSetting(ctx context.Context, arg *ExistsSettingParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsSetting, arg.AccountID, arg.RelationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getFriendPinSettingsOrderByPinTime = `-- name: GetFriendPinSettingsOrderByPinTime :many
select s.relation_id, s.nick_name, s.pin_time,
       a.id     as account_id,
       a.name   as account_name,
       a.avatar as account_avatar
from (select setting.relation_id, setting.nick_name, setting.pin_time
      from setting,
           relation
      where setting.account_id = $1
        and setting.is_pin = true
        and setting.relation_id = relation.id
        and relation.relation_type = 'friend') as s,
     account a
where a.id = (select account_id from setting where relation_id = s.relation_id and (account_id != $1 or is_self = true))
order by s.pin_time
`

type GetFriendPinSettingsOrderByPinTimeRow struct {
	RelationID    int64     `json:"relation_id"`
	NickName      string    `json:"nick_name"`
	PinTime       time.Time `json:"pin_time"`
	AccountID     int64     `json:"account_id"`
	AccountName   string    `json:"account_name"`
	AccountAvatar string    `json:"account_avatar"`
}

func (q *Queries) GetFriendPinSettingsOrderByPinTime(ctx context.Context, accountID int64) ([]*GetFriendPinSettingsOrderByPinTimeRow, error) {
	rows, err := q.db.Query(ctx, getFriendPinSettingsOrderByPinTime, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendPinSettingsOrderByPinTimeRow{}
	for rows.Next() {
		var i GetFriendPinSettingsOrderByPinTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.PinTime,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendSettingsByName = `-- name: GetFriendSettingsByName :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       a.id             as account_id,
       a.name           as account_name,
       a.avatar         as account_avatar,
       count(*) over () as total
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from setting,
           relation
      where setting.account_id = $1
        and setting.relation_id = relation.id
        and relation.relation_type = 'friend') as s,
     account a
where a.id = (select account_id
              from setting
              where relation_id = s.relation_id
                and (account_id != $1 or is_self = true))
  and ((a.name like ($4::varchar || '%')) or (nick_name like ($4::varchar || '%')))
order by s.pin_time
limit $2 offset $3
`

type GetFriendSettingsByNameParams struct {
	AccountID int64  `json:"account_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Name      string `json:"name"`
}

type GetFriendSettingsByNameRow struct {
	RelationID    int64     `json:"relation_id"`
	NickName      string    `json:"nick_name"`
	IsNotDisturb  bool      `json:"is_not_disturb"`
	IsPin         bool      `json:"is_pin"`
	PinTime       time.Time `json:"pin_time"`
	IsShow        bool      `json:"is_show"`
	LastShow      time.Time `json:"last_show"`
	IsSelf        bool      `json:"is_self"`
	AccountID     int64     `json:"account_id"`
	AccountName   string    `json:"account_name"`
	AccountAvatar string    `json:"account_avatar"`
	Total         int64     `json:"total"`
}

func (q *Queries) GetFriendSettingsByName(ctx context.Context, arg *GetFriendSettingsByNameParams) ([]*GetFriendSettingsByNameRow, error) {
	rows, err := q.db.Query(ctx, getFriendSettingsByName,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
		arg.Name,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendSettingsByNameRow{}
	for rows.Next() {
		var i GetFriendSettingsByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendSettingsOrderByName = `-- name: GetFriendSettingsOrderByName :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       a.id     as account_id,
       a.name   as account_name,
       a.avatar as account_avatar
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from setting,
           relation
      where setting.account_id = $1
        and setting.relation_id = relation.id
        and relation.relation_type = 'friend') as s,
     account a
where a.id = (select account_id from setting where relation_id = s.relation_id and (account_id != $1 or is_self = true))
order by s.pin_time
`

type GetFriendSettingsOrderByNameRow struct {
	RelationID    int64     `json:"relation_id"`
	NickName      string    `json:"nick_name"`
	IsNotDisturb  bool      `json:"is_not_disturb"`
	IsPin         bool      `json:"is_pin"`
	PinTime       time.Time `json:"pin_time"`
	IsShow        bool      `json:"is_show"`
	LastShow      time.Time `json:"last_show"`
	IsSelf        bool      `json:"is_self"`
	AccountID     int64     `json:"account_id"`
	AccountName   string    `json:"account_name"`
	AccountAvatar string    `json:"account_avatar"`
}

func (q *Queries) GetFriendSettingsOrderByName(ctx context.Context, accountID int64) ([]*GetFriendSettingsOrderByNameRow, error) {
	rows, err := q.db.Query(ctx, getFriendSettingsOrderByName, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendSettingsOrderByNameRow{}
	for rows.Next() {
		var i GetFriendSettingsOrderByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendShowSettingsOrderByShowTime = `-- name: GetFriendShowSettingsOrderByShowTime :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       a.id     as account_id,
       a.name   as account_name,
       a.avatar as account_avatar
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from setting,
           relation
      where setting.account_id = $1
        and setting.is_show = true
        and setting.relation_id = relation.id
        and relation.relation_type = 'friend') as s,
     account a
where a.id = (select account_id from setting where relation_id = s.relation_id and (account_id != $1 or is_self = true))
order by s.pin_time
`

type GetFriendShowSettingsOrderByShowTimeRow struct {
	RelationID    int64     `json:"relation_id"`
	NickName      string    `json:"nick_name"`
	IsNotDisturb  bool      `json:"is_not_disturb"`
	IsPin         bool      `json:"is_pin"`
	PinTime       time.Time `json:"pin_time"`
	IsShow        bool      `json:"is_show"`
	LastShow      time.Time `json:"last_show"`
	IsSelf        bool      `json:"is_self"`
	AccountID     int64     `json:"account_id"`
	AccountName   string    `json:"account_name"`
	AccountAvatar string    `json:"account_avatar"`
}

func (q *Queries) GetFriendShowSettingsOrderByShowTime(ctx context.Context, accountID int64) ([]*GetFriendShowSettingsOrderByShowTimeRow, error) {
	rows, err := q.db.Query(ctx, getFriendShowSettingsOrderByShowTime, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendShowSettingsOrderByShowTimeRow{}
	for rows.Next() {
		var i GetFriendShowSettingsOrderByShowTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettingByID = `-- name: GetSettingByID :one
select account_id, relation_id, nick_name, is_not_disturb, is_pin, pin_time, is_show, last_show, is_leader, is_self
from setting
where account_id = $1
  and relation_id = $2
`

type GetSettingByIDParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
}

func (q *Queries) GetSettingByID(ctx context.Context, arg *GetSettingByIDParams) (*Setting, error) {
	row := q.db.QueryRow(ctx, getSettingByID, arg.AccountID, arg.RelationID)
	var i Setting
	err := row.Scan(
		&i.AccountID,
		&i.RelationID,
		&i.NickName,
		&i.IsNotDisturb,
		&i.IsPin,
		&i.PinTime,
		&i.IsShow,
		&i.LastShow,
		&i.IsLeader,
		&i.IsSelf,
	)
	return &i, err
}

const updateSettingDisturb = `-- name: UpdateSettingDisturb :exec
update setting
set is_not_disturb = $3
where account_id = $1
  and relation_id = $2
`

type UpdateSettingDisturbParams struct {
	AccountID    int64 `json:"account_id"`
	RelationID   int64 `json:"relation_id"`
	IsNotDisturb bool  `json:"is_not_disturb"`
}

func (q *Queries) UpdateSettingDisturb(ctx context.Context, arg *UpdateSettingDisturbParams) error {
	_, err := q.db.Exec(ctx, updateSettingDisturb, arg.AccountID, arg.RelationID, arg.IsNotDisturb)
	return err
}

const updateSettingLeader = `-- name: UpdateSettingLeader :exec
update setting
set is_leader = $3
where account_id = $1
  and relation_id = $2
`

type UpdateSettingLeaderParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
	IsLeader   bool  `json:"is_leader"`
}

func (q *Queries) UpdateSettingLeader(ctx context.Context, arg *UpdateSettingLeaderParams) error {
	_, err := q.db.Exec(ctx, updateSettingLeader, arg.AccountID, arg.RelationID, arg.IsLeader)
	return err
}

const updateSettingNickName = `-- name: UpdateSettingNickName :exec
update setting
set nick_name = $3
where account_id = $1
  and relation_id = $2
`

type UpdateSettingNickNameParams struct {
	AccountID  int64  `json:"account_id"`
	RelationID int64  `json:"relation_id"`
	NickName   string `json:"nick_name"`
}

func (q *Queries) UpdateSettingNickName(ctx context.Context, arg *UpdateSettingNickNameParams) error {
	_, err := q.db.Exec(ctx, updateSettingNickName, arg.AccountID, arg.RelationID, arg.NickName)
	return err
}

const updateSettingPin = `-- name: UpdateSettingPin :exec
update setting
set is_pin = $3
where account_id = $1
  and relation_id = $2
`

type UpdateSettingPinParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
	IsPin      bool  `json:"is_pin"`
}

func (q *Queries) UpdateSettingPin(ctx context.Context, arg *UpdateSettingPinParams) error {
	_, err := q.db.Exec(ctx, updateSettingPin, arg.AccountID, arg.RelationID, arg.IsPin)
	return err
}
